"use strict";(self.webpackChunkData_in_Design=self.webpackChunkData_in_Design||[]).push([[7623],{17623:(t,e,i)=>{i.r(e),i.d(e,{default:()=>m});var a=i(35143),s=i(76460),o=i(50346),r=i(46053),n=(i(18690),i(40565),i(85842)),h=i(14509),d=i(75185),p=i(4176),l=i(91196),c=i(771);let u=class extends((0,c.A)((0,d.e)(l.A))){update(t){this._strategy.update(t).catch((t=>{(0,o.zf)(t)||s.A.getLogger(this.declaredClass).error(t)})),this.notifyChange("updating")}attach(){this._bitmapContainer=new h.l,this.container.addChild(this._bitmapContainer),this._strategy=new p.A({container:this._bitmapContainer,fetchSource:this.fetchBitmapData.bind(this),requestUpdate:this.requestUpdate.bind(this)})}detach(){this._strategy.destroy(),this._strategy=null,this.container.removeChild(this._bitmapContainer),this._bitmapContainer.removeAllChildren()}moveStart(){}viewChange(){}moveEnd(){this.requestUpdate()}fetchBitmapData(t,e,i){return this.layer.fetchImage(t,e,i)}async doRefresh(){this.requestUpdate()}isUpdating(){return this._strategy.updating||this.updateRequested}};(0,a._)([(0,r.MZ)()],u.prototype,"_strategy",void 0),(0,a._)([(0,r.MZ)()],u.prototype,"updating",void 0),u=(0,a._)([(0,n.$)("esri.views.2d.layers.BaseDynamicLayerView2D")],u);const m=u},4176:(t,e,i)=>{i.d(e,{A:()=>C});var a=i(35143),s=i(13398),o=(i(81806),i(50346)),r=i(46053),n=(i(18690),i(40565),i(85842)),h=i(2413),d=i(80963),p=i(88235);const l=Math.PI/180;function c(t){return t*l}function u(t,e){const i=c(e.rotation),a=Math.abs(Math.cos(i)),s=Math.abs(Math.sin(i)),[o,r]=e.size;return t[0]=Math.round(r*s+o*a),t[1]=Math.round(r*a+o*s),t}var m=i(16060),g=i(40181),y=i(93453);const _=(0,h.vt)(),f=[0,0],x=new y.A(0,0,0,0),M=2048,v=2048,w=!1,b=!1,S=!1;let R=class extends s.A{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=S,this.imageMaxWidth=M,this.imageMaxHeight=v,this.imageRotationSupported=w,this.imageNormalizationSupported=b,this.update=(0,o.sg)((async(t,e)=>{if((0,o.Te)(e),!t.stationary||this.destroyed)return;const i=t.state,a=(0,d.Vp)(i.spatialReference),s=this.hidpi?t.pixelRatio:1,r=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0];r?(f[0]=i.worldScreenWidth,f[1]=i.size[1]):this.imageRotationSupported?(f[0]=i.size[0],f[1]=i.size[1]):u(f,i);const n=Math.floor(f[0]*s)>this.imageMaxWidth||Math.floor(f[1]*s)>this.imageMaxHeight,h=a&&(i.extent.xmin<a.valid[0]||i.extent.xmax>a.valid[1]),p=!this.imageNormalizationSupported&&h,l=!n&&!p,c=this.imageRotationSupported?i.rotation:0,m=this.container.children.slice();if(l){const t=r?i.paddedViewState.center:i.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(i,f,t,i.resolution,c,s,e)}else{let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);p&&(t=Math.min(i.worldScreenWidth,t)),this._imagePromise=this._tiledExport(i,t,s,e)}try{const t=await this._imagePromise;(0,o.Te)(e);const i=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=null!==t&&void 0!==t?t:[];for(const e of m)t.includes(e)||i.push(e.fadeOut().then((()=>{e.remove(),e.destroy()})));for(const e of t)i.push(e.fadeIn());await Promise.all(i)}catch(g){this._imagePromise=null,(0,o.QP)(g)}}),5e3),this.updateExports=(0,o.sg)((async t=>{const e=[];for(const i of this.container.children){if(!i.visible||!i.stage)return;e.push(t(i).then((()=>{i.invalidateTexture(),i.requestRender()})))}this._imagePromise=(0,o.Lx)(e).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((t=>t.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(t,e,i,a,s,r){const n=await this.fetchSource(t,Math.floor(e*s),Math.floor(i*s),{rotation:a,pixelRatio:s,signal:r});(0,o.Te)(r);const h=new m.mb(null,{immutable:!0,requestRenderOnSourceChangedEnabled:!0});return h.x=t.xmin,h.y=t.ymax,h.resolution=t.width/e,h.rotation=a,h.pixelRatio=s,h.opacity=0,this.container.addChild(h),await h.setSourceAsync(n,r),(0,o.Te)(r),h}async _singleExport(t,e,i,a,s,o,r){!function(t,e,i,a){const[s,o]=e,[r,n]=a,h=.5*i;t[0]=s-h*r,t[1]=o-h*n,t[2]=s+h*r,t[3]=o+h*n}(_,i,a,e);const n=(0,h.w1)(_,t.spatialReference);return[await this._export(n,e[0],e[1],s,o,r)]}_tiledExport(t,e,i,a){const s=p.A.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),o=new g.A(s),r=o.getTileCoverage(t);if(!r)return null;const n=[];return r.forEach(((s,r,d,p)=>{x.set(s,r,d,0),o.getTileBounds(_,x);const l=(0,h.w1)(_,t.spatialReference);n.push(this._export(l,e,e,0,i,a).then((t=>(0!==p&&(x.set(s,r,d,p),o.getTileBounds(_,x),t.x=_[0],t.y=_[3]),t))))})),Promise.all(n)}};(0,a._)([(0,r.MZ)()],R.prototype,"_imagePromise",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"bitmaps",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"container",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"fetchSource",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"hidpi",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"imageMaxWidth",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"imageMaxHeight",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"imageRotationSupported",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"imageNormalizationSupported",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"requestUpdate",void 0),(0,a._)([(0,r.MZ)()],R.prototype,"updating",null),R=(0,a._)([(0,n.$)("esri.views.2d.layers.support.ExportStrategy")],R);const C=R},771:(t,e,i)=>{i.d(e,{A:()=>d});var a=i(35143),s=i(76460),o=i(50346),r=i(68134),n=i(46053),h=(i(18690),i(40565),i(85842));const d=t=>{let e=class extends t{initialize(){this.handles.add((0,r.on)((()=>this.layer),"refresh",(t=>{this.doRefresh(t.dataChanged).catch((t=>{(0,o.zf)(t)||s.A.getLogger(this.declaredClass).error(t)}))})),"RefreshableLayerView")}};return(0,a._)([(0,n.MZ)()],e.prototype,"layer",void 0),e=(0,a._)([(0,h.$)("esri.layers.mixins.RefreshableLayerView")],e),e}}}]);
//# sourceMappingURL=7623.6137f25f.chunk.js.map