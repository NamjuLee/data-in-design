{"version":3,"file":"static/js/9174.42db6a69.chunk.js","mappings":"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","sources":["PART_06_Problem_Data_Model_Train_Validation/LAB_Web_03_MPGPrediction/index.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs';\r\nimport * as tfvis from '@tensorflow/tfjs-vis';\r\nimport '@tensorflow/tfjs-backend-webgl';\r\n\r\nexport class Solution {\r\n  public destroy() {\r\n\r\n  }\r\n  constructor(id: string) {\r\n    //  https://js.tensorflow.org/api/latest/\r\n    console.log(\"Let's learn TF JS !!\");\r\n    console.log(\"==============================\");\r\n\r\n    execute();\r\n    console.log('Playground done!');\r\n  }\r\n};\r\nconst execute = async () => {\r\n  const data = await getData();\r\n  console.log(data);\r\n  visData(data);\r\n\r\n  const tensor = await convertToTensor(data);\r\n  console.log(tensor)\r\n\r\n  const model = createModel()\r\n\r\n  await trainModel(model, tensor.inputs, tensor.labels);\r\n\r\n  testModel(model, data, tensor);\r\n\r\n}\r\nconst getData = async () => {\r\n  const carsDataResponse = await fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json');\r\n  const carsData = await carsDataResponse.json();\r\n  const cleaned = carsData.map(car => ({\r\n    mpg: car.Miles_per_Gallon,\r\n    horsepower: car.Horsepower,\r\n  }))\r\n    .filter(car => (car.mpg != null && car.horsepower != null));\r\n\r\n  return cleaned;\r\n};\r\n\r\nconst visData = async (data) => {\r\n  const values = data.map(d => ({\r\n    x: d.horsepower,\r\n    y: d.mpg,\r\n  }));\r\n\r\n  tfvis.render.scatterplot(\r\n    { name: 'Horsepower v MPG' },\r\n    { values },\r\n    {\r\n      xLabel: 'Horsepower',\r\n      yLabel: 'MPG',\r\n      height: 300\r\n    }\r\n  );\r\n\r\n}\r\n\r\nconst createModel = () => {\r\n  // Create a sequential model\r\n  const model = tf.sequential();\r\n\r\n  // Add a single input layer\r\n  model.add(tf.layers.dense({ inputShape: [1], units: 1, useBias: true }));\r\n\r\n  // Add an output layer\r\n  model.add(tf.layers.dense({ units: 1, useBias: true }));\r\n\r\n  return model;\r\n}\r\n\r\n\r\nconst convertToTensor = async (data) => {\r\n  return tf.tidy(() => {\r\n    // Step 1. Shuffle the data\r\n    tf.util.shuffle(data);\r\n\r\n    // Step 2. Convert data to Tensor\r\n    const inputs = data.map(d => d.horsepower)\r\n    const labels = data.map(d => d.mpg);\r\n\r\n    const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);\r\n    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);\r\n\r\n    //Step 3. Normalize the data to the range 0 - 1 using min-max scaling\r\n    const inputMax = inputTensor.max();\r\n    const inputMin = inputTensor.min();\r\n    const labelMax = labelTensor.max();\r\n    const labelMin = labelTensor.min();\r\n\r\n    const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));\r\n    const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));\r\n\r\n    return {\r\n      inputs: normalizedInputs,\r\n      labels: normalizedLabels,\r\n      // Return the min/max bounds so we can use them later.\r\n      inputMax,\r\n      inputMin,\r\n      labelMax,\r\n      labelMin,\r\n    }\r\n  });\r\n}\r\n\r\nconst trainModel = async (model, inputs, labels) => {\r\n  // Prepare the model for training.\r\n  model.compile({\r\n    optimizer: tf.train.adam(),\r\n    loss: tf.losses.meanSquaredError,\r\n    metrics: ['mse'],\r\n  });\r\n\r\n  const batchSize = 32;\r\n  const epochs = 30;\r\n\r\n  return await model.fit(inputs, labels, {\r\n    batchSize,\r\n    epochs,\r\n    shuffle: true,\r\n    callbacks: tfvis.show.fitCallbacks(\r\n      { name: 'Training Performance' },\r\n      ['loss', 'mse'],\r\n      { height: 200, callbacks: ['onEpochEnd'] }\r\n    )\r\n  });\r\n}\r\n\r\nconst testModel = (model, inputData, normalizationData) => {\r\n  const { inputMax, inputMin, labelMin, labelMax } = normalizationData;\r\n\r\n  const [xs, preds] = tf.tidy(() => {\r\n\r\n    const xs = tf.linspace(0, 1, 100);\r\n    const preds = model.predict(xs.reshape([100, 1]));\r\n\r\n    const unNormXs = xs.mul(inputMax.sub(inputMin)).add(inputMin);\r\n\r\n    const unNormPreds = preds.mul(labelMax.sub(labelMin)).add(labelMin);\r\n\r\n    // Un-normalize the data\r\n    return [unNormXs.dataSync(), unNormPreds.dataSync()];\r\n  });\r\n\r\n  const predictedPoints = Array.from(xs).map((val, i) => {\r\n    return { x: val, y: preds[i] }\r\n  });\r\n\r\n  const originalPoints = inputData.map(d => ({\r\n    x: d.horsepower, y: d.mpg,\r\n  }));\r\n\r\n  tfvis.render.scatterplot(\r\n    { name: 'Model Predictions vs Original Data' },\r\n    { values: [originalPoints, predictedPoints], series: ['original', 'predicted'] },\r\n    {\r\n      xLabel: 'Horsepower',\r\n      yLabel: 'MPG',\r\n      height: 300\r\n    }\r\n  );\r\n}"],"names":["Solution","destroy","constructor","id","console","log","execute","async","data","getData","visData","tensor","convertToTensor","model","createModel","trainModel","inputs","labels","testModel","carsDataResponse","fetch","json","map","car","mpg","Miles_per_Gallon","horsepower","Horsepower","filter","values","d","x","y","tfvis","scatterplot","name","xLabel","yLabel","height","tf","add","inputShape","units","useBias","inputTensor","length","labelTensor","inputMax","max","inputMin","min","labelMax","labelMin","sub","div","compile","optimizer","adam","loss","meanSquaredError","metrics","fit","batchSize","epochs","shuffle","callbacks","fitCallbacks","inputData","normalizationData","xs","preds","predict","reshape","unNormXs","mul","unNormPreds","dataSync","predictedPoints","Array","from","val","i","originalPoints","series"],"sourceRoot":""}